=== Contents ===

1: Introduction
   1.1: Citation Details

2: Installation
   2.0: Preliminaries
   2.1: Manual Installation
   2.2: Installation on Linux / Mac OS X
   2.3: Installation on MS Windows

3: Compiling Programs and Linking
   3.0: Examples
   3.1: Compiling & Linking on Linux / Mac OS X
   3.2: Compiling & Linking on MS Windows

4: Caveats
   4.0: Support for ATLAS
   4.1: Support for ACML and Intel MKL

5: Documentation / Reference Manual

6: Using Armadillo with IT++

7: FAQs and Bug Reports

8: Credits

9: License




=== 1.0: Introduction ===

Armadillo is a C++ linear algebra library (matrix maths)
aiming towards a good balance between speed and ease of use.
Integer, floating point and complex numbers are supported,
as well as a subset of trigonometric and statistics functions.
Various matrix decompositions are provided through optional
integration with LAPACK or high-performance LAPACK-compatible
libraries.

A delayed evaluation approach is employed (during compile time)
to combine several operations into one and reduce (or eliminate)
the need for temporaries. This is accomplished through recursive
templates and template meta-programming.

This library is useful if C++ has been decided as the language
of choice (due to speed and/or integration capabilities),
rather than another language like Matlab or Octave.
It is distributed under a license that is useful in both
open-source and proprietary contexts.

Armadillo is primarily developed at NICTA (Australia),
with contributions from around the world.
More information about NICTA can be obtained from:
  http://nicta.com.au



=== 1.1: Citation Details ===

If you use Armadillo in your research and/or software,
we would appreciate a citation to the following tech report:

  Conrad Sanderson.
  Armadillo: An Open Source C++ Linear Algebra Library for
  Fast Prototyping and Computationally Intensive Experiments.
  Technical Report, NICTA, 2010.



=== 2.0: Installation: Preliminaries ===

Armadillo makes extensive use of template meta-programming,
recursive templates and template based function overloading.
As such, C++ compilers which do not fully implement the C++
standard may not work correctly.

The functionality of Armadillo is partly dependent on other
libraries -- mainly LAPACK and BLAS. Armadillo can work without
LAPACK or BLAS, but its functionality will be reduced.
In particular, basic functionality will be available
(eg. matrix addition and multiplication), but things like
eigen decomposition or will not be. Matrix multiplication
(mainly for big matrices) may not be as fast.

For manual installation on all systems, see section 2.1.

For installation on Linux / Mac OS X systems, see section 2.2.
The Linux installation is also likely to work on other Unix-like
systems, such as FreeBSD, NetBSD, OpenBSD, Solaris, CygWin, etc.

For installation on MS Windows, see section 2.3.



=== 2.1: Manual Installation ===

The manual installation is comprised of 3 steps:

* Step 1:
  Copy the entire "include" folder to a convenient location
  and tell your compiler to use that location for header files
  (in addition to the locations it uses already).
  Alternatively, you can use the "include" folder directly.

* Step 2:
  Modify "include/armadillo_bits/config.hpp" to indicate 
  which libraries are currently available on your system.
  For example, if you have LAPACK and BLAS present, 
  uncomment the following lines:
  
  #define ARMA_USE_LAPACK
  #define ARMA_USE_BLAS

* Step 3:
  If you have LAPACK and/or BLAS present, configure your 
  compiler to link with these libraries. 
  
  You can also link with the the equivalent of LAPACK and BLAS,
  eg. Intel's MKL or AMD's ACML. Under Mac OS X, link using 
  -framework Accelerate



=== 2.2: Installation on Linux / Mac OS X ===

If you have installed Armadillo using an RPM or DEB package,
you don't need to do anything else. Otherwise read on.

You can use the manual installation process as described in
section 2.1, or the following CMake based automatic installation.

* Step 1:
  If CMake is not already be present on your system, download
  it from http://www.cmake.org

  On major Linux systems (such as Fedora, Ubuntu, Debian, etc),
  cmake is available as a pre-built package, though it may need
  to be explicitly installed (using a tool such as PackageKit,
  yum, rpm, apt, aptitude, etc).
  
* Step 2:
  If you have BLAS and/or LAPACK, install them before installing
  Armadillo. Under Mac OS X this is not necessary.
  
  On Linux systems it is recommended that the following libraries
  are present: LAPACK, BLAS, ATLAS and Boost. LAPACK and BLAS are
  the most important. If you have ATLAS and Boost, it's also necessary
  to have the corresponding header files installed.
  
* Step 3:
  Open a shell (command line), change into the directory that was
  created by unpacking the armadillo archive, and type the following
  commands:
  
  cmake .
  make 
  
  The full stop separated from "cmake" by a space is important.
  CMake will figure out what other libraries are currently installed
  and will modify Armadillo's configuration correspondingly.
  CMake will also generate a run-time armadillo library, which is a 
  combined alias for all the relevant libraries present on your system
  (eg. BLAS, LAPACK and ATLAS).
  
  If you need to re-run cmake, it's a good idea to first delete the
  "CMakeCache.txt" file (not "CMakeLists.txt").
  
* Step 4:
  If you have access to root/administrator/superuser privileges,
  first enable the privileges (eg. through "su" or "sudo")
  and then type the following command:
  
  make install
  
  If you don't have root/administrator/superuser privileges, 
  type the following command:
  
  make install DESTDIR=my_usr_dir
  
  where "my_usr_dir" is for storing C++ headers and library files.
  Make sure your C++ compiler is configured to use the sub-directories
  present within this directory.



=== 2.3: Installation on MS Windows ===

There is currently no automatic installation for Windows.
Please use the manual installation process described in section 2.1.

Pre-compiled BLAS and LAPACK libraries for Windows are provided
in the "examples/libs_win32" folder. If the provided libraries
don't work for you, see section 3.2.



=== 3.0: Compiling Programs and Linking: Examples ===

The "examples" directory contains several quick example programs
that use the Armadillo library. If Armadillo was installed manually
(ie. according to section 2.1), you will also need to explicitly
link your programs with the libraries that were specified in
"include/armadillo_bits/config.hpp".

"example1.cpp" may require the BLAS library or its equivalent.
"example2.cpp" requires the LAPACK library or its equivalent
(eg. the Accelerate framework on Mac OS X).

You may get errors at compile or run time if BLAS and/or LAPACK
functions are not available.

NOTE: As Armadillo is a template library, we recommended that
      optimisation is enabled during compilation. For example,
      for the GCC compiler use -O1 or -O2



=== 3.1: Compiling & Linking on Linux / Mac OS X ===

Please see "examples/Makefile", which may may need to be configured
for your system. If Armadillo header files were installed in a
non-standard location, you will need to modify "examples/Makefile"
to tell the compiler where they are.

In general, programs which use Armadillo are compiled along these lines:
  g++ example1.cpp -o example1 -O1 -larmadillo

(you may also need to specify the include directory via the -I switch)

If you get linking errors, or if Armadillo was installed manually
and you specified that LAPACK and BLAS are available, you will
need to explicitly link with LAPACK and BLAS (or their equivalents),
for example:
  g++ example1.cpp -o example1 -O1 -llapack -lblas

(you may also need to specify the library directory via the -L switch)

Notes:
  * under most Linux systems, using "-llapack -lblas" should be enough;
    however, on Ubuntu and Debian you may need to add "-lgfortran"
    
  * under Mac OS X, try "-framework Accelerate" or "-llapack -lblas"
    (the Accelerate option is usually the fastest)
    
  * under the Sun Studio compiler, try "-library=sunperf"



=== 3.2: Compiling & Linking on MS Windows ===

As a courtesy, we've provided pre-compiled 32 bit versions of
LAPACK and BLAS for Windows, as well as MSVC project files to
compile example1.cpp and example2.cpp. The project files are
stored in the following folders:
  examples/example1_win32
  examples/example2_win32

The LAPACK and BLAS libraries are stored in:
  examples/lib_win32

If you're not using MSVC, you will need to manually modify 
"include/armadillo_bits/config.hpp" to enable the use of
LAPACK and BLAS. Please see section 2.1 for more information.

The MSCV project files were tested on Windows XP (32 bit) with
Visual C++ 2008 (Express Edition). You may need to make adaptations
for 64 bit systems, later versions of Windows and/or the compiler.
For example, you may have to enable or disable the ARMA_BLAS_LONG
and ARMA_BLAS_UNDERSCORE macros in "armadillo_bits/config.hpp".

To preserve our sanity, we (Armadillo developers) don't use Windows
on a regular basis, and as such can't help you with the adaptations.

The pre-compiled versions of LAPACK and BLAS were downloaded from:
  http://www.fi.muni.cz/~xsvobod2/misc/lapack/

If the provided libraries don't work for you, try these versions:
  http://www.stanford.edu/~vkl/code/libs.html
  http://icl.cs.utk.edu/lapack-for-windows/lapack/
  http://software.intel.com/en-us/intel-mkl/
  http://www.amd.com/acml

(the MKL and ACML libraries are generally the fastest)


If you want to compile BLAS and LAPACK yourself, you can find
the original sources at:
  http://www.netlib.org/blas/
  http://www.netlib.org/lapack/

If you encounter issues with the MS Visual C++ compiler,
the following high-quality compilers are useful alternatives:

  - Intel's C++ compiler
    http://software.intel.com/en-us/intel-compilers/

  - GCC (part MinGW)
    http://www.mingw.org/

  - GCC (part of CygWin)
    http://www.cygwin.com/

If using Intel's C++ compiler, you'll need version 10.0 or better.
If using GCC, you'll need version 4.0 or better.



=== 4.0: Caveats: Support for ATLAS ===

Armadillo can use the ATLAS library for faster versions of
certain LAPACK and BLAS functions. Not all ATLAS functions are
currently used, and as such LAPACK should still be installed.

The minimum recommended version of ATLAS is 3.8.
Old versions (eg. 3.6) can produce incorrect results
as well as corrupting memory, leading to random crashes.

Users of Ubuntu and Debian based systems should explicitly
check that version 3.6 is not installed. It's better to
remove the old version and use the standard LAPACK library.



=== 4.1: Caveats: Support for ACML and Intel MKL ===

Armadillo can work with AMD Core Math Library and Intel's
Math Kernel Library (MKL), however there are several caveats.

On Linux systems, ACML and MKL are typically installed in a
non-standard location, which can cause problems during linking.

Before installing Armadillo, the system should know where the ACML or MKL
libraries are located (eg., "/opt/intel/mkl/10.2.2.025/lib/em64t/").
This can be achieved by setting the LD_LIBRARY_PATH environment variable,
or, for a more permanent solution, adding the location of the libraries
to "/etc/ld.so.conf". It may also be possible to store a text file 
with the location in the "/etc/ld.so.conf.d" directory.
In the latter two cases you will need to run "ldconfig" afterwards.

The default installations of ACML 4.4.0 and MKL 10.2.2.025 are known 
to have issues with SELinux, which is turned on by default in Fedora
(and possibly RHEL). The problem may manifest itself during run-time,
where the run-time linker reports permission problems.
It is possible to work around the problem by applying an appropriate
SELinux type to all ACML and MKL libraries.

If you have ACML or MKL installed and they are persistently giving
you problems during linking, you can disable the support for them
by editing the "CMakeLists.txt" file, deleting "CMakeCache.txt" and
re-running the CMake based installation. Specifically, comment out
the lines containing:
  INCLUDE(ARMA_FindMKL)
  INCLUDE(ARMA_FindACMLMP)
  INCLUDE(ARMA_FindACML)



=== 5: Documentation / Reference Manual ===

A reference manual (user documentation) is available at
http://arma.sourceforge.net or in the "docs" directory.
Use a web browser to open the "docs/index.html" file.

The user documentation explains how to use Armadillo's
classes and functions, with snippets of example code.



=== 6: Using Armadillo with IT++ ===

If you wish to use the IT++ library in conjunction with Armadillo,
use #include "armadillo_itpp" instead of #include "armadillo"
in your code. See also the "examples/example_itpp.cpp" file.



=== 7: FAQs and Bug Reports ===

Answers to Frequently Asked Questions (FAQs) can be found at:
  http://arma.sourceforge.net/faq.html

This library has gone through extensive testing and
has been successfully used in production environments.
However, as with almost all software, it's impossible
to guarantee 100% correct functionality.

If you find a bug in the library (or the documentation),
we are interested in hearing about it. Please make a small
self-contained program which exposes the bug and send the
program source (as well as the bug description) to the 
developers. The developers' contact details are available at:
  http://arma.sourceforge.net/contact.html

Alternatively, you can post the source and bug description
on Armadillo's discussion board:
  http://sourceforge.net/apps/phpbb/arma/



=== 8: Credits ===

Main sponsoring organisation:
- CSU  - http://

Main developers:
- Xingyu Zhang - http://

Contributors:
- 




=== 9: License ===

Please see the "LICENSE.txt" file.





从网上看了一篇使用andriod的toolchain在cygwin上来建立android的开发环境，但是在vista上编译始终失败，在xp上能够成功。但是编译的时间比较长，而且对于新手来说也比较麻烦，难道就没有简单的方法吗？
google已经把andriod的ndk已经放出来了，所以我就想着打它的主意了，把它配置一下，就能来开发c的程序了。旁边小伙肯定笑了，“搞啥？，有病啊，ndk就是一个开发native code的环境。”
大哥，我当然知道了，虽然使用ndk来开发native code相对容易，但是它的.mk文件我看的是云里雾里，我本来想调用自己写的另外一个so库，都不知道在.mk文件里如何写，
我现在也懒的去看ndk里面的mk文件，等哪天（哪天？天晓得是哪一天）有空了好好研究一下。好了，闲话少说，开练吧。首先安装cygwin,这个网上的教程多的是，就不说了，
接着下载android ndk，这个在andriod的官网上就有了，然后下载一个从android模拟器里取system lib的工具busybox,然后调用命令
$adb push busybox /dev/sample/busybox
$adb shell chmod 777 /dev/sample/busybox
$adb shell ./dev/sample/busybox tar -cf /dev/sample/libs.tar /system/lib
$adb pull /dev/sample/libs.tar libs.tar
这样就将模拟器下的 /system/lib 目录的所有库（so）文件打包并下载下来了，解压libs.tar就得到了我们所需要的所有库文件。
接着将所有的文件copy 到 $（NDK）\build\prebuilt\windows\arm-eabi-4.2.1\lib\gcc\arm-eabi\4.2.1,好了，这个时候基本的配置工作就结束了，怎么样简单多了吧。
接着编写一个简单的c文件 tutorial01.c
#include <stdio.h>
int getinformation() 
{
 return 0;
}
然后编写一个Makefile文件
CC = /cygdrive/f/software/android/android-ndk-1.5_r1/build/prebuilt/windows/arm-eabi-4.2.1/bin/arm-eabi-gcc


CFLAGS  = -g -O2 -fPIC -DANDROID -I ./ -I ../  -I F:/software/android/android-ndk-1.5_r1/build/platforms/android-1.5/arch-arm/usr/include
SDFLAGS = -nostdlib -Wl,-T,armelf.xsc -Wl,-soname,$@ -Wl,-shared,-Bsymbolic -lc 
CRT_OBJS= -lz -lm
all: libtutorial01.so


libtutorial01.so: tutorial01.o
 $(CC) $(SDFLAGS) -o $@ tutorial01.o  $(CRT_OBJS)


tutorial01.o: tutorial01.c
然后make，这个时候会报错 can't find "armelf.xsc", 在ndk的目录里搜索一下，搜到之后copy 到$（NDK）\build\prebuilt\windows\arm-eabi-4.2.1\lib\gcc\arm-eabi\4.2.1，然后make，成功。这样一个简单的so文件就生成了，这个时候如果想在android的虚拟机上运行，我们还需要给它包装一下。再编写一个文件test01.c,在这里是使用dl动态加载so文件，静态加载始终有问题，搞不清楚android是如何搜索目录，而且现在只能用绝对路径，这个问题还得仔细研究研究。
#include <string.h>
#include <jni.h>


jint
Java_com_example_testffmpeg_testffmpeg_getinformation( JNIEnv* env,
                                                  jobject thiz )
{
 void*  filehandle = dlopen("/data/data/com.example.test/lib/libtutorial.so", RTLD_LAZY );
 int ll = -1;
 if(filehandle)
 {
 int( * getinformation ) (); 
 getinformation = dlsym(filehandle, "getinformation");
 if( getinformation )
 {
 ll = getinformation();
 }
 else
 {
 ll = -3;
 }
 dlclose(filehandle);
 filehandle=0;
 }
 else
 {
 ll = -2;
 }
    return ll;
}
同样再来一个Makefile文件
CC = /cygdrive/f/software/android/android-ndk-1.5_r1/build/prebuilt/windows/arm-eabi-4.2.1/bin/arm-eabi-gcc


CFLAGS  = -g -O2 -fPIC -DANDROID  -I ./ -I ../  -I F:/software/android/android-ndk-1.5_r1/build/platforms/android-1.5/arch-arm/usr/include
SDFLAGS = -nostdlib -Wl,-T,armelf.xsc -Wl,-shared,-Bsymbolic -Wl,-soname,$@ -lc  -L ../tutorial
CRT_OBJS= -lz -lm  -ldl
all: libtest01.so


libtest01.so: test01.o
 $(CC) $(SDFLAGS) -o $@ test01.o  $(CRT_OBJS)




ok, make一下成功。好了，接下来使用andriod的sdk写一个简单的activity， testapp来测试其运行情况，以下是test01.java的代码。
package com.example.test;


import android.app.Activity;
import android.widget.TextView;
import android.os.Bundle;




public class test01 extends Activity
{
    /** Called when the activity is first created. */
    @Override
    public void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);


        /* Create a TextView and set its content.
         * the text is retrieved by calling a native
         * function.
         */
        TextView  tv = new TextView(this);
       // tv.setText( stringFromJNI() );
        Integer ll = getinformation();
        String lls = ll.toString();
        tv.setText(lls);
        setContentView(tv);
    }


    /* A native method that is implemented by the
     * 'hello-jni' native library, which is packaged
     * with this application.
     */
    public native int  getinformation();
     /* this is used to load the 'hello-jni' library on application
     * startup. The library has already been unpacked into
     * /data/data/com.example.HelloJni/lib/libhello-jni.so at
     * installation time by the package manager.
     */
    static {
     
     System.loadLibrary("test");
     }
}


在eclipse中运行，在模拟器上显示0，就表示成功了。
附件是busybox和例子程序。

